{"componentChunkName":"component---src-templates-blog-post-js","path":"/elm-chrome-ext/","webpackCompilationHash":"46cb4da29686213d041f","result":{"data":{"site":{"siteMetadata":{"title":"TorchShip logs","author":"Dwight Doane"}},"markdownRemark":{"id":"0d882815-6845-5620-81d3-355ce4890923","excerpt":"First let’s start with a bit of background. I got a job as an Elm developer winter 2018. At the time I didn’t know Elm so I had to learn in a hurry. I had the…","html":"<p>First let’s start with a bit of background.</p>\n<p>I got a job as an Elm developer winter 2018.</p>\n<p>At the time I didn’t know Elm so I had to learn in a hurry.</p>\n<p>I had the idea for a chrome extension than can update the images I use on a website or app. But to go along with the chrome extension I had to build a whole dashboard (which I’ll write more about that later).</p>\n<p>Over the next weeks and months I built and rebuilt the app I call <a href=\"https://tryvertol.com\">Vertol</a>.\nI learned how to build an Elm application by reverse engineering our app at work, as well as looking over <a href=\"https://github.com/rtfeldman/elm-spa-example\">Richard Feldman’s SPA</a> app  and a number of other tutorials.</p>\n<p>Researching “how to build a chrome extension in Elm” didn’t yield much besides ”<a href=\"https://github.com/danneu/elm-chrome-extension\">danneu/elm-chrome-extension: a chrome extension composed of three elm apps that synchronize a single model</a>”. Looking at how <a href=\"https://github.com/danneu\">danneu</a> structured their extension helped a lot with getting something set up. I took a lot of inspiration from danneu. I ended up needing all 3 main components of a chrome extension. A background script, popup script and content script. I have seperate webpack configs for the dashboard and the extension.</p>\n<p>I’m trying to keep all the business logic in Elm, and pass messages out through ports as needed. It’s still very much a work in progress but I’m pretty happy with how things have turned out.</p>\n<p>If you’re familiar with ports, it’s not too difficult to get working. Following a similar set up as <a href=\"https://www.youtube.com/watch?v=P3pL85n9_5s\">Murphy Randle’s pattern</a> of working with ports, I was able to connect the chrome runtime with the different parts of the extension. It seems to “scale” pretty well. So everything you already know about ports makes working with Chrome a piece of cake. It’s not too dissimilar to Elm’s ports.</p>\n<p>My directory structure is a little different than danneu though.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4aa5da3b64cd77046396541371d7f367/50bbc/extension.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 155.82010582010582%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAfCAYAAADnTu3OAAAACXBIWXMAABYlAAAWJQFJUiTwAAADn0lEQVRIx52VSXPbRhCFBwsHO7gBIHYQ3CXKTqjYsrM4cZy4klgHV6p8cM75/7/hpXsIRirLpkkduoYAgQ8z/V53C8uyMG2nuN5d43JzAU3TIIQ4Gm3bYjweYz6fq3U0HGJIwdf0v4ZBf4AoSzDKE9iWDfEVqO04kNJCEARq5fA8D2HYp3fpAdfsQRYenJsYdZrBdSzwfVPXYGjiQfB/WgfXu9W1LVjShHB7Ao4tMR6EePbihrbdoi4yGN2DJgF6OsPvonc/DKGe7fsuAo9OZ9FN37UQDUNklzvUlM+2ypHGY4oRXMvcQ4xPQJ+EZWoqhMqJbSMMfLhXP6OYr1HmKZqmUcln0fgZFusUwRRQSknAAEkSY/PdDbI8P+XF40BWTJA4F57ElI47JQtUZYksy1AUxf9xbJdBu7oD9sOQLnT8UAg0sYs0LzGlY1dVpaBRFKn4LKz7SPn2/R7Y4yN3wA9vBWa1g3AQq3tjgoxG4+PH7ID563d7HzqWxLAfkrd0vLmmL00cyucEEzp6XRbI0wmSOFK/rZ6pPMh+1Lsw9D2wenNLPjQFPPJhPArJpDpuXwpcLXxSukQ8DOA7tHuyFa998hlbg20iOxvxKukee7H5jYChZJdL9bJBovzxo45N42G9XCEa+KoSlNe0vckVgMK6t1r3gbxV9trQc+HPlwje/YOUCn65WmJGPjRNo/PhXck9iO7I5a+3d6L0fR8m5Wn4/TOkUYyyqpX6J3nvIMoBKDugT8lvf3mFhHbIdjFN8yxgcR/o+x7SNMfT3XOkkwlmsxkMw3g8MCDgpKhw9eKVAnKzVNXzGKBFPvQ8ag6uTULEyKmWV6uVWrkTc1fWdf08oOv6CFxSKhKI4glKNjQBOZccR4//OaAfDPDvXwK7bQIeC2d1mAc5JB9yPwyf/4l8vqGOnZNI/uOBbGzPcTG6IUGWa7R1rXLHYnHzdWgoHRrtaUAaMD29h+zbGtW6RNvMVKUsFgulNlsoTdPTus1+BNCUMxx8fC1w2Too6znqqlSj8Zwjl7+/P+zQhqS2NJ5XGFNXbqjsWOEkSc4Sx6/nhxzasAko2m/g51PUeaZgJY2Ao/770kzhHErTQrMrML2oaIdT1fZrEudRQ2oPlIieEGhRYda0yMk6PEoHg8H5QBbFNCR2LzNU0yHyrFS74wrhsmPLsC9d11U2+koX2gN108bfPwlczAKyzBbr9UpZ5mCb7XaLzWajapzT8SXgf6UQudJYyWvhAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"directory structure\"\n        title=\"directory structure\"\n        src=\"/static/4aa5da3b64cd77046396541371d7f367/b9e4f/extension.png\"\n        srcset=\"/static/4aa5da3b64cd77046396541371d7f367/cf440/extension.png 148w,\n/static/4aa5da3b64cd77046396541371d7f367/d2d38/extension.png 295w,\n/static/4aa5da3b64cd77046396541371d7f367/b9e4f/extension.png 590w,\n/static/4aa5da3b64cd77046396541371d7f367/50bbc/extension.png 756w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>The <code class=\"language-text\">Main.elm</code> you see is for the dashboard application.</p>\n<p>The source code for the chrome extension shares code with Vertol’s dashboard. So to make things easy I just have the whole source for the extension inside the <code class=\"language-text\">src</code> folder, <code class=\"language-text\">manifest.json</code> and all, and I just simply <code class=\"language-text\">gitignore</code> the compiled output.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">package.json\n<span class=\"token string\">\"build-ext-prod\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"webpack --config config/webpack.ext.js &amp;&amp; npm run zip-ext\"</span>,\n<span class=\"token string\">\"zip-ext\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"zip -r vertol.zip src/extension\"</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token comment\">// webpack.ext.js config </span>\n entry<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    popup<span class=\"token operator\">:</span> paths.extPopupJs<span class=\"token punctuation\">,</span>\n    bg<span class=\"token operator\">:</span> paths.extBGJS<span class=\"token punctuation\">,</span>\n    content<span class=\"token operator\">:</span> paths.extContentJS<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n  output<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    pathinfo<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    <span class=\"token comment\">// The build folder.</span>\n    path<span class=\"token operator\">:</span> paths.appSrc<span class=\"token punctuation\">,</span>\n    filename<span class=\"token operator\">:</span> 'extension/<span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">]</span>/<span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">]</span>.bundle.js'<span class=\"token punctuation\">,</span>\n    publicPath<span class=\"token operator\">:</span> publicPath<span class=\"token punctuation\">,</span>\n    chunkFilename<span class=\"token operator\">:</span> '<span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">]</span>.bundle.js'<span class=\"token punctuation\">,</span>\n    ...more config\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span></code></pre></div>\n<p>Then a build script <code class=\"language-text\">npm run build-ext-prod</code> packages it so it’s ready to load in a browser.</p>\n<p>I’m including the source code as a gist because the whole source is private for now. </p>\n<h4>How the extension is built:</h4>\n<ul>\n<li>\n<p><code class=\"language-text\">src/extension/</code></p>\n<ul>\n<li>\n<p><a href=\"https://gist.github.com/imdwit/e9ac44f6341460ee24262c801399254c\"><code class=\"language-text\">/bg/bg.js</code></a></p>\n<ul>\n<li>handles connecting the <code class=\"language-text\">Background.elm</code> to the chrome runtime</li>\n<li>adds images to the “staging” area passed to it from the content script</li>\n<li>“seeds” assets to the content script when a user has images in the “staging” area</li>\n<li>requests a signed url for uploading to s3</li>\n<li>coordinates injecting the content script</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://gist.github.com/imdwit/9ae109eb3a4a57f73fe5c7a9bbc4700f\"><code class=\"language-text\">/popup/init.popup.js</code></a></p>\n<ul>\n<li>connects the Popup to the the background script</li>\n<li>handles log in</li>\n<li>sets up message handlers to connect the <code class=\"language-text\">Popup.elm</code> model to the chrome runtime</li>\n<li>when a user opens the popup from the chrome extension it asks for the <code class=\"language-text\">Popup</code> model from <code class=\"language-text\">Background.elm</code></li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://gist.github.com/imdwit/5e6f28fdccf45bbffe21a2e97014506b\"><code class=\"language-text\">/content/content.js</code></a></p>\n<ul>\n<li>responsible for injecting some css and adding event handlers to enable drag and drop of new images</li>\n<li>when an image is selected it is base64 encoded and passed to <code class=\"language-text\">Background</code> to cache in what I call a ‘staging’ area</li>\n<li>when a user hits save the image is uploaded to s3 and updated ion the DB</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://gist.github.com/imdwit/24e3e48c8a8d31bcfaba4dfb2e43c2e2\"><code class=\"language-text\">src/Background.elm</code></a></p>\n<p><code class=\"language-text\">Background.elm</code> and <code class=\"language-text\">bg.js</code> are the brain, it persists the state for Popup.model, and handles the xhr requests. Passing messages back and forth between the popup, as well as the content scripts. Im taking advantage of Elm’s <code class=\"language-text\">Platform.worker</code> since there’s no DOM.</p>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"elm\"><pre class=\"language-elm\"><code class=\"language-elm\"><span class=\"token comment\">-- Background model</span>\n<span class=\"token keyword\">type</span> <span class=\"token keyword\">alias</span> <span class=\"token constant\">Model</span> <span class=\"token operator\">=</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token hvariable\">popUp</span> <span class=\"token operator\">:</span> <span class=\"token constant\">PopUp.Model</span>\n    <span class=\"token punctuation\">,</span> <span class=\"token hvariable\">hostname</span> <span class=\"token operator\">:</span> <span class=\"token constant\">String</span>\n    <span class=\"token punctuation\">,</span> <span class=\"token hvariable\">projects</span> <span class=\"token operator\">:</span> <span class=\"token constant\">List</span> <span class=\"token constant\">Project</span>\n    <span class=\"token punctuation\">,</span> <span class=\"token hvariable\">staging</span> <span class=\"token operator\">:</span> <span class=\"token constant\">Dict</span> <span class=\"token constant\">String</span> <span class=\"token constant\">Asset.Preview</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>\n<p><a href=\"https://gist.github.com/imdwit/afc9c0bd03254cb1605db6c61e5652a7\"><code class=\"language-text\">src/Popup.elm</code></a></p>\n<p>Popup lets you log in (more features coming soon), and passes that data to background, so it can check if you own this site/app to enable the content scripts.\nBeing that chrome extension popups are effectively stateless, every time you open the popup it has to reinit the app. So storing the state of <code class=\"language-text\">Popup</code>’s model in <code class=\"language-text\">Background</code> makes it super simple to pass the model in as flags. When Popups model changes, it gets passed to Background so the next time the popup is open it’s initialized with the right state.</p>\n</li>\n</ul>\n<p>After you login and it registers the fact that the website you’re on is one of your projects. The content scripts wire up the event handlers for updating your images. It registers drop events on the <code class=\"language-text\">&lt;img/&gt;</code> tags to enable drag and drop. When an image file is selected it is then base64 encoded and passed to <code class=\"language-text\">Background</code> where it can remain cached in its model (seen above)</p>\n<p><code class=\"language-text\">{staging : Dict String Asset.Preview}</code></p>\n<p>So in the event a user accidentally refreshes, or navigates away from the page, the user doesn’t have to reselect new images, and they can just hit save to upload the replacements.When a user hits ‘save’, Background requests a signed url from the api for a PUT request for the S3 bucket where images are stored. The image is uploaded, and progress events are sent to the content script to increment a progress bar on the image.</p>\n<p><code class=\"language-text\">Popup</code> and <code class=\"language-text\">Background</code> are essentially independent elm applications that send messages out through <em>elm</em> ports to the chrome runtime’s ports.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">src/extension/content/content.js</code></p>\n<p>The content script first injects some css to style the buttons and progress bars for new images. The script finds all the images by using the <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors\">attribute selector</a> <code class=\"language-text\">&#39;[src*=&quot;imgix.net&quot;]&#39;</code>. This selector finds all images stored in Vertol’s cdn provider. After finding the images it adds drag and drop event handlers to them to handle showing previews and uploading new replacements.\n<code class=\"language-text\">content.js</code> also uses <code class=\"language-text\">chrome.extension.sendMessage</code> to send messages to <code class=\"language-text\">chrome.runtime.onMessage.addListener</code> in <a href=\"https://gist.github.com/imdwit/e9ac44f6341460ee24262c801399254c\"><code class=\"language-text\">bg.js</code></a>. For instance there’s an <code class=\"language-text\">addFileToStaging</code> message that puts the base64 encoded image into <code class=\"language-text\">Background.elm</code>’s staging <code class=\"language-text\">Dict</code>.\nWhen a new image is selected the image is replaced inline with a base64 encoded version, but not yet saved. The user has the option to undo selecting that image, which puts the image back how they found it. Or they can hit ‘save’ which dispatches an <code class=\"language-text\">upload</code> event to <code class=\"language-text\">bg.js</code> which then uploads the image to S3. Content then receives progress events to update the progress bar’s value to indicate to the user something is happening.</p>\n</li>\n</ul>\n<p>Thanks for checking out this quick tour of my chrome extension. I learned a ton making it and hope to improve upon it in the near future. If you have any questions feel free to reach out to <a href=\"https://twitter.com/iamdwit\">me on twitter.</a></p>","frontmatter":{"title":"How I built a Chrome extension with Elm","date":"August 22, 2019","description":"Building a chrome extension with Elm and a bit of JavaScript"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/elm-chrome-ext/","previous":null,"next":null}}}